Understand: Create Book class (halfway done already) and make books objects, not dictionaries. Add applicable methods to book class. Create function to convert dictionaries to objects, and store in list. Convert remaining functions to use new book list. Improve checkout and return functions by adding confirmation messages and checks if book is already available/unavailable. Create function that shows top 3 most checked out books. Create simple CLI that shows available books, allows search, allows checkout, allows return, shows overdue books, and shows top 3 most checked out books. When going from assemble to solve, implement any suggestions by Ruff.

Clues:
I will be using classes since the requirements said so. I will also be using a loop and a half structure for the CLI to allow the user to select multiple options until they're done with the program. I will be using lists to store all the books I can search through them.

Assemble:
class Book:
    function init(self, 
    book_id, 
    title, 
    author, 
    genre, 
    available, 
    due_date, 
    checkouts):
        self.book_id = book_id
        self.title = title
        self.author = author
        self.genre = genre
        self.available = available
        self.due_date = due_date
        self.checkouts = checkouts
    
    function checkout_book(self):
        IF NOT self.available:
            PRINT Book is unavailable.
        ELSE:
            self.available = FALSE
            self.checkouts += 1
            self.due_date = datetime.now() + timedelta(weeks=2)
            PRINT Book checked out succesfully.
    
    function return_book(self):
        self.available = True
        self.due_date = None
        PRINT Book returned succesfully.

books_list = []

function books_to_objects():
    FOR book in library_books:
        books_list.append(Book(
            book[id],
            book[title],
            book[author],
            book[genre],
            book[available],
            book[due_date],
            book[checkouts]))

function show_available_books():
    table = prettytable
    table.toprow(Book ID, Title, Author)
    FOR book IN books_list:
        IF book.available:
            table.append(book.book_id, book.title, book.author)
    PRINT table

function search_books(query):
    matching_books = []
    FOR book IN books_list:
        IF book.author.lower() == query.lower() OR book.genre.lower() == query.lower():
            matching_books.append(book)
    RETURN matching_books

function show_overdue_books():
    table = prettytable
    table.toprow(Book ID, Title, Author)
    FOR book in books_list:
        IF NOT book.available:
            time_difference = book.due_date - datetime.now()
            IF time_difference.total_seconds() < 0:
                table.append(book.book_id, book.title, book.author)
    PRINT table

function show_top_checkouts():
    table = prettytable
    table.toprow(Book ID, Title, Author)
    temp_books_list = books_list
    top_books = []
    REPEAT 3:
        max = 0
        top_book = None
        FOR book in temp_books_list:
            IF book.checkouts > max:
                max = book.checkouts
                top_book = book
        top_books.append(top_book)
        table.append(top_book.book_id, top_book.title, top_book.author)
        temp_books_list.remove(top_book)
    
function show_cli():
    PRINT Welcome to the Library Management System!\n
    WHILE True:
        PRINT Please select one of the following options:
        PRINT 1. Show available books.
        PRINT 2. Search for book.
        PRINT 3. Checkout book.
        PRINT 4. Return book.
        PRINT 5. Show overdue books.
        PRINT 6. Show top 3 most checked out books.
        PRINT 7. Exit.
        menu_option = INPUT Enter a number: 
        IF menu_option == 1:
            show_available_books()
        ELSE IF menu_option == 2:
            table = prettytable
            table.toprow(Book ID, Title, Author)
            user_query = INPUT Enter your search query:
            FOR book IN search_books(user_query):
                table.append(book.book_id, book.title, book.author)
            PRINT table
        ELSE IF menu_option == 3:
            user_query = INPUT Enter the ID of the book you want to checkout: 
            FOR book in books_list:
                IF book.book_id == user_query:
                    book.checkout_book()
                    BREAK
            ELSE:
                PRINT No matching book ID.
        ELSE IF menu_option == 4:
            user_query = INPUT Enter the ID of the book you want to return: 
            FOR book in books_list:
                IF book.book_id == user_query:
                    book.return_book()
                    BREAK
            ELSE:
                PRINT No matching book ID.
        ELSE IF menu_option == 5:
            show_overdue_books()
        ELSE IF menu_option == 6:
            show_top_checkouts()
        ELSE IF menu_option == 7:
            PRINT Thanks for using the Library Management System. Goodbye!
            BREAK
        ELSE:
            PRINT Please enter a valid menu option. Valid options are (1, 2, 3, 4, 5, 6, 7).

Solve:
class Book:
    """Class representing each book in the library."""

    # Initialize Book object with its attributes.
    def __init__(  # noqa: PLR0913
        self,
        book_id: str,
        title: str,
        author: str,
        genre: str,
        available: bool,  # noqa: FBT001
        due_date: datetime | None,
        checkouts: int) -> None:
        """Initialize a Book object."""
        self.book_id = book_id
        self.title = title
        self.author = author
        self.genre = genre
        self.available = available
        self.due_date = due_date
        self.checkouts = checkouts

    def checkout_book(self) -> None:
        """Checkout a book."""
        # Check if book is available.
        if not self.available:
            # Print unavailable message.
            print("Book is unavailable.")
        else:
            # Set book availability to false.
            # Increment checkouts by 1.
            # Set due date to 2 weeks from now.
            self.available = False
            self.checkouts += 1
            self.due_date = datetime.now(tz=timezone.utc) + timedelta(weeks=2)

            # Print success message.
            print("Book checked out successfully.")

    def return_book(self) -> None:
        """Return a book."""
        # Set book availability to True.
        # Clear due date.
        self.available = True
        self.due_date = None

        # Print success message.
        print("Book returned successfully.")

books_list: list[Book] = []

def books_to_objects() -> None:
    """Convert library_books dicts to Book objects and store in books_list."""
    # Iterate through each book in library_books.
    for book in library_books:
        # Convert due_date from str to datetime if necessary.
        if type(book["due_date"]) is str:
            book["due_date"] = datetime.fromisoformat(book["due_date"])
            book["due_date"] = book["due_date"].replace(tzinfo=timezone.utc)

        # Create Book object for each book and append to books_list.
        books_list.append(Book(
            book_id=book["id"],
            title=book["title"],
            author=book["author"],
            genre=book["genre"],
            available=book["available"],
            due_date=book["due_date"], # pyright: ignore[reportArgumentType]
            checkouts=book["checkouts"],
        ))

def show_available_books() -> None:
    """Display all available books in a table format."""
    # Create table with headers.
    table = PrettyTable()
    table.field_names = ["Book ID", "Title", "Author"]

    # Append row to table for each available book.
    for book in books_list:
        if book.available:
            table.add_row([book.book_id, book.title, book.author])

    # Show table.
    print(table)

def search_books(query: str) -> list[Book]:
    """Search for books by matching author or genre. Return list of matching books."""
    # Empty list to hold matching books.
    matching_books: list[Book] = []

    # Check each book for matching author or genre.
    # If matching, append to matching_books list.
    for book in books_list:
        if (book.author.lower() == query.lower() or book.genre.lower() == query.lower()):  # noqa: E501
            matching_books.append(book)

    # Return matching books.
    return matching_books

def show_overdue_books() -> None:
    """Display all overdue books in a table format."""
    # Create table with headers.
    table = PrettyTable()
    table.field_names = ["Book ID", "Title", "Author"]

    # Append row to table for each overdue book.
    for book in books_list:
        if not book.available and book.due_date is not None:
            # Get time difference between due date and now.
            time_difference: timedelta = book.due_date.replace(tzinfo=timezone.utc) - datetime.now(tz=timezone.utc)  # noqa: E501

            # If time difference is negative, add book to table.
            if time_difference.total_seconds() < 0:
                table.add_row([book.book_id, book.title, book.author])

    # Show table.
    print(table)

def show_top_checkouts() -> None:
    """Display the top 3 most checked out books."""
    # Create table with headers.
    table = PrettyTable()
    table.field_names = ["Book ID", "Title", "Author"]

    # Temporary copy of books_list for finding top books.
    temp_books_list = books_list.copy()
    # List to store top 3 books. Functionally useless, will be used later.
    top_books: list[Book] = []

    # Iterate through temp_books_list 3 times.
    for _ in range(3):
        # Initialize variables used to find top book.
        max_checkouts = 0
        top_book: Book | None = None

        # Iterate through each book in temp_books_list.
        for book in temp_books_list:
            # Update variables if book is currently the maximum so far.
            # After going through all books, top_book will be the top book.
            if book.checkouts > max_checkouts:
                max_checkouts = book.checkouts
                top_book = book

        # Append top book to top_books list.
        top_books.append(top_book) # pyright: ignore[reportArgumentType]
        # Remove top book from temp_books_list to find next top book in next iteration.
        temp_books_list.remove(top_book) # pyright: ignore[reportArgumentType]

        # Append top book to table.
        table.add_row([top_book.book_id, top_book.title, top_book.author]) # pyright: ignore[reportOptionalMemberAccess]

    # Show table.
    print(table)

def show_cli() -> None:  # noqa: C901, PLR0912
    """Run the user-interactable command line interface."""
    # Print welcome message.
    print("Welcome to the Library Management System!\n")
    while True:
        # Show all the options.
        print("Please select one of the following options:")
        print("1. Show available books.")
        print("2. Search for book.")
        print("3. Checkout book.")
        print("4. Return book.")
        print("5. Show overdue books.")
        print("6. Show top 3 most checked out books.")
        print("7. Exit")
        # Ask user for numerical menu option, raise error if they don't give a number.
        try:
            menu_option = int(input("Enter a number: "))
        except ValueError:
            print("Invalid input. Please enter a number.")
            break

        # Run code based on user input.
        if menu_option == 1:
            # Show available books.
            show_available_books()
        elif menu_option == 2:
            # Create table with headers.
            table = PrettyTable()
            table.field_names = ["Book ID", "Title", "Author"]

            # Ask user for search query.
            user_query = input("Enter your search query: ")
            # Append row to table for each matching book.
            for book in search_books(user_query):
                table.add_row([book.book_id, book.title, book.author])

            # Show table.
            print(table)
        elif menu_option == 3:
            # Ask user for book ID to checkout book.
            user_query = input("Enter the ID of the book you want to checkout: ")

            # Iterate through books to find matching ID.
            for book in books_list:
                if book.book_id == user_query:
                    # Checkout book.
                    book.checkout_book()
                    break
            else:
                # Print message if no matching book ID.
                print("No matching book ID.")
        elif menu_option == 4:
            # Ask user for book ID to return book.
            user_query = input("Enter the ID of the book you want to return: ")

            # Iterate through books to find matching ID.
            for book in books_list:
                if book.book_id == user_query:
                    # Return book.
                    book.return_book()
                    break
            else:
                # Print message if no matching book ID.
                print("No matching book ID.")
        elif menu_option == 5:
            # Show overdue books.
            show_overdue_books()
        elif menu_option == 6:
            # Show top 3 most checked out books.
            show_top_checkouts()
        elif menu_option == 7:
            # Show goodbye message.
            print("Thanks for using the Library Management System. Goodbye!")
            # Exit program.
            break
        else:
            # Print message if menu option is invalid.
            # Split into two lines to reduce line length.
            print("Please enter a valid menu option.", end=" ")
            print("Valid options are (1, 2, 3, 4, 5, 6, 7).")

Examine:
The code is very functional and performant. The base functionality is perfect and it includes some quality of life features like checking user input and if books are available/unavailable. The performance is good (it's a simple Python program, it's going to be performant either way). The readability is good in some parts but is lacking in others, like in the class definition. The CLI is pretty usable but some formatting changes could help usability as well.